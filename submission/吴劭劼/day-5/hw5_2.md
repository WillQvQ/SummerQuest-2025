1. 
1.1 
Gpipe调度策略：所有前向传播完成后再执行所有反向传播
前向传播阶段： 第一个microbatch需要经过所有p个阶段，耗时p × t_f；后续(m-1)个microbatch每个增加t_f。
反向传播阶段： 第一个microbatch需要经过所有p个阶段，耗时p × t_b；后续(m-1)个microbatch每个增加t_b。
T_total= [p×t_f + (m-1)×t_f] + [p×t_b + (m-1)×t_b]
        = (p + m - 1)×t_f + (p + m - 1)×t_b
        = (p + m - 1)×(t_f + t_b)
将数值代入公式：
T_total = (4 + 8 - 1) × (2 + 4) = 11 × 6 = 66ms
1.2 
T_ideal = m × (t_f + t_b)
将数值代入公式：
T_ideal = 8 × (2 + 4) = 8 × 6 = 48ms
1.3 
Bubble Ratio = (T_total - T_ideal) / T_total
将数值代入公式：
Bubble Ratio = (66 - 48) / 66 = 18 / 66 = 3/11 ≈ 0.273 = 27.3%
2. 
T_total = (p + m - 1) × (t_f + t_b) = (4 + 16 - 1) × 6 = 19 × 6 = 114ms
T_ideal = m × (t_f + t_b) = 16 × 6 = 96ms
Bubble Ratio = (114 - 96) / 114 = 18 / 114 = 3/19 ≈ 0.158 = 15.8%
Bubble Ratio从 27.3% 降低到 15.8%。
原因： 当microbatch数量 m 增加时，流水线的启动开销 (p-1) 被摊薄到更多的microbatch上，从而提高了流水线利用率。
数学原理： Bubble Ratio = (p-1)/(p+m-1)，当 m 增大时，分母增大而分子不变，所以比率下降。
3. 
3.1 内存使用优化
Gpipe： 需要存储所有microbatch的中间激活值，直到反向传播开始。
1F1B： 采用交替的前向-反向模式，可以更早地释放中间激活值，显著减少内存峰值占用。
3.2 流水线气泡减少
Gpipe： 存在明显的流水线气泡，特别是在前向和反向传播的切换阶段。
1F1B： 通过交替执行前向和反向传播，减少了流水线中的空闲时间（“气泡”）。
3.3 更好的负载均衡
Gpipe： 前向传播和反向传播是分离的两个阶段，可能导致某些阶段的GPU利用率不均。
1F1B： 更均匀地分配计算负载，能更好地保持各阶段GPU的持续工作。
3.4 数值稳定性
Gpipe： 长时间存储激活值可能导致数值精度问题（stale activations）。
1F1B： 更快的梯度更新循环，有助于保持训练的数值稳定性。
3.5 收敛速度
1F1B： 由于更频繁的梯度更新（权重更新更及时），通常能获得更好的收敛性能。