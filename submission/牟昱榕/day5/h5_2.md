# 答题卡

## 1 总训练时间与理想时间

### 1.1

在 Gpipe 调度中，所有微批次（microbatch）的前向传播（forward pass）作为一个阶段全部完成后，才开始所有微批次的反向传播（backward pass）阶段。这中间会产生一个较大的空闲时间，即“流水线气泡（pipeline bubble）”。

总执行时间的计算可以分为两个主要部分：
1.  **前向传播阶段**：从第一个微批次在第一张 GPU 上开始，到最后一个微批次在最后一张 GPU 上完成前向传播为止。这个过程可以看作是最后一个微批次（第 $$m$$ 个）进入流水线（耗时 $$(m-1)t_f$$）并完成在所有 $$p$$ 个阶段的传播（耗时 $$p \times t_f$$）。因此，整个前向传播阶段的耗时为 $$(m-1+p)t_f$$。
2.  **反向传播阶段**：紧接着前向阶段结束，反向传播开始。类似地，从最后一个微批次（按计算顺序是第 $$m$$ 个）在最后一张 GPU 上开始反向传播，到第一个微批次在第一张 GPU 上完成反向传播为止。整个反向传播阶段的耗时为 $$(m-1+p)t_b$$。

由于 Gpipe 的调度特性，这两个阶段是完全分离的，因此总时间是两个阶段耗时之和。

推导的总时间公式为：
$$T_{\text{total}} = (p + m - 1) \times t_f + (p + m - 1) \times t_b = (p + m - 1) \times (t_f + t_b)$$

根据已知条件代入计算：
- $$p = 4$$
- $$m = 8$$
- $$t_f = 2 \text{ms}$$
- $$t_b = 4 \text{ms}$$

$$T_{\text{total}} = (4 + 8 - 1) \times (2 + 4) = 11 \times 6 = 66 \text{ms}$$

### 1.2

理想执行时间是指在没有任何流水线气泡（即硬件始终满负荷工作）的情况下，完成所有微批次所需的计算时间。这相当于将所有微批次在一个单点上串行执行其前向和反向传播的总和。

理想执行时间公式为：
$$T_{\text{ideal}} = m \times (t_f + t_b)$$

根据已知条件代入计算：
$$T_{\text{ideal}} = 8 \times (2 + 4) = 8 \times 6 = 48 \text{ms}$$

### 1.3

气泡比例（Bubble Ratio）衡量了由于流水线启动和排空阶段造成的空闲时间占理想执行时间的比例。它反映了流水线并行的效率。

气泡比例公式为：
$$\text{Bubble Ratio} = \frac{T_{\text{total}}}{T_{\text{ideal}}}$$

根据以上计算结果：
$$\text{Bubble Ratio} = \frac{66 \text{ms}}{48 \text{ms}} = \frac{11}{8} = 1.375$$

## 2 若将 microbatch 数增加为 $$m = 16$$，bubble ratio 会如何变化？请分析并说明原因

若将微批次数增加为 $$m = 16$$，气泡比例会**减小**。

**计算与分析：**

1.  **重新计算总执行时间 ($$T_{\text{total}}$$)**
    $$T_{\text{total}} = (4 + 16 - 1) \times (2 + 4) = 19 \times 6 = 114 \text{ms}$$

2.  **重新计算理想执行时间 ($$T_{\text{ideal}}$$)**
    $$T_{\text{ideal}} = 16 \times (2 + 4) = 16 \times 6 = 96 \text{ms}$$

3.  **重新计算气泡比例**
    $$\text{Bubble Ratio} = \frac{114 \text{ms}}{96 \text{ms}} = \frac{19}{16} = 1.1875$$

可以看到，气泡比例从 1.375 降低到了 1.1875。

**原因分析：**

流水线并行的总时间由两部分构成：纯计算时间（理想时间）和流水线气泡时间。气泡时间主要由流水线的“启动”阶段（第一个微批次流经所有 GPU）和“排空”阶段（最后一个微批次流经所有 GPU）产生。
- **理想时间** ($$T_{\text{ideal}}$$) 与微批次数 $$m$$ 成正比：$$m \times (t_f + t_b)$$。
- **气泡时间** ($$T_{\text{bubble}} = T_{\text{total}} - T_{\text{ideal}}$$) 主要与流水线深度 $$p$$ 相关，为 $$(p-1) \times (t_f + t_b)$$。这部分开销是固定的，与微批次数 $$m$$ 无关。

气泡比例的表达式可以写为：
$$\text{Bubble Ratio} = \frac{m \times (t_f + t_b) + (p-1) \times (t_f + t_b)}{m \times (t_f + t_b)} = 1 + \frac{p-1}{m}$$

从这个表达式可以看出，当流水线深度 $$p$$ 固定时，气泡比例与微批次数 $$m$$ 成反比。增加 $$m$$ 的值，意味着将固定的气泡开销分摊到更多的计算任务上，从而使得气泡时间占总时间的比重下降，流水线效率得以提升。

## 3. 与 Gpipe 相比，1F1B 调度策略在哪些方面优化了流水线利用率？

与 Gpipe 在所有前向传播完成后再执行所有反向传播的策略不同，1F1B（One Forward, One Backward）调度策略通过交错执行前向和反向传播来优化流水线利用率。 其主要优化体现在以下方面：

1.  **显著减少流水线气泡**：1F1B 策略的核心优势是大幅缩减了 Gpipe 中存在的巨大空闲时间（气泡）。 在 Gpipe 中，第一张 GPU 在完成所有微批次的前向传播后，必须等待流水线中最后一个微批次完成其在所有 GPU 上的前向传播，然后才能开始反向传播，这造成了巨大的等待空闲。 而在 1F1B 中，一旦某个微批次完成了前向传播，其对应的反向传播就可以被调度执行，无需等待所有微批次都完成前向传播。

2.  **提高设备利用率**：通过将前向和反向传播任务交错执行，1F1B 策略使得 GPU 在流水线的“稳定状态”阶段能够持续地进行计算，要么是前向传播，要么是反向传播。 这减少了设备的空闲等待时间，从而显著提高了硬件的整体利用率。

3.  **降低峰值内存**：1F1B 调度能够更早地开始并完成反向传播。 由于反向传播完成后，为前向传播存储的激活值（activation）就可以被释放，因此这种“即用即算即释放”的模式有效降低了需要同时保留在内存中的激活值的数量，从而降低了峰值内存占用。 虽然 Gpipe 也可以通过重计算来换取内存，但这会带来额外的计算开销。